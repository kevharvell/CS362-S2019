
 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases actions by 2
Current hand count: 5
Expected number of actions: 3 	Actual number actions: 4
TEST FAILED: action count incorrect.

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage decreases deck count by 1
Current hand count: 5
Expected number of cards in deck: 9 	Actual number of cards in deck: 9

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card when deck count is 1
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:89
        -:    0:Programs:88
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1740 returned 100% blocks executed 83%
     1740:    8:int compare(const void* a, const void* b) {
     1740:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1740:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      464:   12:		return -1;
     1276:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 58 returned 100% blocks executed 88%
       58:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       58:   44:	SelectStream(1);
call    0 returned 100%
       58:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       58:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       58:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      638:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6380:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     5800:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       58:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       58:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       58:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       58:   89:		state->supplyCount[estate] = 8;
       58:   90:		state->supplyCount[duchy] = 8;
       58:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       58:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       58:  102:	state->supplyCount[silver] = 40;
       58:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1218:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
     9570:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     8990:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      580:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      116:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       58:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      522:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      580:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8410:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      174:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      116:  140:		state->deckCount[i] = 0;
      464:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      348:  143:			state->deck[i][j] = estate;
      348:  144:			state->deckCount[i]++;
        -:  145:		}
      928:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      812:  148:			state->deck[i][j] = copper;
      812:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      174:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      116:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      174:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      116:  166:		state->handCount[i] = 0;
      116:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1624:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1566:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       58:  182:	state->outpostPlayed = 0;
       58:  183:	state->phase = 0;
       58:  184:	state->numActions = 1;
       58:  185:	state->numBuys = 1;
       58:  186:	state->playedCardCount = 0;
       58:  187:	state->whoseTurn = 0;
       58:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      348:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      290:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       58:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       58:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 347 returned 100% blocks executed 100%
      347:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      347:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      347:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      231:  210:		return -1;
      116:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1392:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1160:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1160:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1160:  217:		newDeckPos++;
     4698:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3538:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1160:  221:		state->deckCount[player]--;
        -:  222:	}
     1276:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1160:  224:		state->deck[player][i] = newDeck[i];
     1160:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      116:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 258 returned 100% blocks executed 100%
      258:  349:int whoseTurn(struct gameState *state) {
      258:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 963 returned 100% blocks executed 88%
      963:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      963:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      231:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      231:  542:		state->deckCount[player] = state->discardCount[player];
      231:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      231:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      231:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      231:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      231:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      231:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      231:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      231:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      231:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      732:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      732:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      732:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      732:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      732:  580:		state->deckCount[player]--;
      732:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      732:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 40 returned 100% blocks executed 69%
       40:  650:int playAdventurer(struct gameState *state) {
       40:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       40:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       40:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      160:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       80:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       80:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       80:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       80:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       80:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       80:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       40:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 25 returned 100% blocks executed 100%
       25:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       25:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      125:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      100:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       25:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       75:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       50:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       25:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       25:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       25:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 80 returned 100% blocks executed 100%
       80:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       80:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      480:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      400:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       80:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       80:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 207 returned 100% blocks executed 78%
      207: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      207: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      196: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      196: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      207: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      207: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      207: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      207: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      207: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      207: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      207: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 58 returned 100% blocks executed 82%
       58: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       58: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      348: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      290: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      232: 1357:			state->coins += 1;
        -: 1358:		}
       58: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       58: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       58: 1370:	state->coins += bonus;
        -: 1371:
       58: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 9
Expected number of cards in hand: 7 	Actual number of cards in hand: 9
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 7 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy decreases deck count by 3 (when deck has 3 cards)
Current hand count: 5
Current hand count: 6
Current hand count: 7
Deck count now: 0
Current hand count: 8
Deck count now: 0
Current hand count: 8
Expected number of cards in deck: 0 	Actual number of cards in deck: 0

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy - player's deck count is >= 0 when decreased by 3 (when deck has < 3 cards)
Current hand count: 5
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Number of cards in deck: 0

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:90
        -:    0:Programs:89
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1740 returned 100% blocks executed 83%
     1740:    8:int compare(const void* a, const void* b) {
     1740:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1740:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      464:   12:		return -1;
     1276:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 58 returned 100% blocks executed 88%
       58:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       58:   44:	SelectStream(1);
call    0 returned 100%
       58:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       58:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       58:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      638:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6380:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     5800:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       58:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       58:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       58:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       58:   89:		state->supplyCount[estate] = 8;
       58:   90:		state->supplyCount[duchy] = 8;
       58:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       58:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       58:  102:	state->supplyCount[silver] = 40;
       58:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1218:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
     9570:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     8990:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      580:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      116:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       58:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      522:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      580:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8410:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      174:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      116:  140:		state->deckCount[i] = 0;
      464:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      348:  143:			state->deck[i][j] = estate;
      348:  144:			state->deckCount[i]++;
        -:  145:		}
      928:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      812:  148:			state->deck[i][j] = copper;
      812:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      174:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      116:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      174:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      116:  166:		state->handCount[i] = 0;
      116:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1624:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1566:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       58:  182:	state->outpostPlayed = 0;
       58:  183:	state->phase = 0;
       58:  184:	state->numActions = 1;
       58:  185:	state->numBuys = 1;
       58:  186:	state->playedCardCount = 0;
       58:  187:	state->whoseTurn = 0;
       58:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      348:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      290:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       58:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       58:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 358 returned 100% blocks executed 100%
      358:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      358:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      358:  209:	if (state->deckCount[player] < 1)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
      242:  210:		return -1;
      116:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1392:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1160:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1160:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1160:  217:		newDeckPos++;
     4698:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3538:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1160:  221:		state->deckCount[player]--;
        -:  222:	}
     1276:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1160:  224:		state->deck[player][i] = newDeck[i];
     1160:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      116:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 262 returned 100% blocks executed 100%
      262:  349:int whoseTurn(struct gameState *state) {
      262:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 983 returned 100% blocks executed 88%
      983:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      983:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      242:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      242:  542:		state->deckCount[player] = state->discardCount[player];
      242:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      242:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      242:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      242:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      242:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      242:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      242:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      242:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      242:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      741:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      741:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      741:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      741:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      741:  580:		state->deckCount[player]--;
      741:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      741:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 40 returned 100% blocks executed 69%
       40:  650:int playAdventurer(struct gameState *state) {
       40:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       40:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       40:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      160:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       80:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       80:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       80:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       80:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       80:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       80:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       40:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 25 returned 100% blocks executed 100%
       25:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       25:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      125:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      100:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       25:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       75:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       50:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       25:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       25:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       25:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 84 returned 100% blocks executed 100%
       84:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       84:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      504:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      420:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       84:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       84:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 211 returned 100% blocks executed 78%
      211: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      211: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      200: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      200: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      211: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      211: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      211: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      211: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      211: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      211: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      211: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 58 returned 100% blocks executed 82%
       58: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       58: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      348: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      290: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      232: 1357:			state->coins += 1;
        -: 1358:		}
       58: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       58: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       58: 1370:	state->coins += bonus;
        -: 1371:
       58: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand count by 2 and discards the card
Current hand count: 5
Current hand count: 6
Expected number of cards in hand: 6 	Actual number of cards in hand: 7
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand TREASURE count by 2
Current hand count: 5
Current hand count: 6
Expected number of treasures in hand: 6 	Actual number of treasures in hand: 4
TEST FAILED: treasure count incorrect after playing adventurer.

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:91
        -:    0:Programs:90
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1770 returned 100% blocks executed 83%
     1770:    8:int compare(const void* a, const void* b) {
     1770:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1770:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      472:   12:		return -1;
     1298:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 59 returned 100% blocks executed 88%
       59:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       59:   44:	SelectStream(1);
call    0 returned 100%
       59:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       59:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       59:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      649:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6490:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     5900:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       59:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       59:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       59:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       59:   89:		state->supplyCount[estate] = 8;
       59:   90:		state->supplyCount[duchy] = 8;
       59:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       59:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       59:  102:	state->supplyCount[silver] = 40;
       59:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1239:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
     9735:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9145:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      590:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      118:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       59:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      531:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      590:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8555:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      177:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      118:  140:		state->deckCount[i] = 0;
      472:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      354:  143:			state->deck[i][j] = estate;
      354:  144:			state->deckCount[i]++;
        -:  145:		}
      944:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      826:  148:			state->deck[i][j] = copper;
      826:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      177:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      118:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      177:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      118:  166:		state->handCount[i] = 0;
      118:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1652:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1593:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       59:  182:	state->outpostPlayed = 0;
       59:  183:	state->phase = 0;
       59:  184:	state->numActions = 1;
       59:  185:	state->numBuys = 1;
       59:  186:	state->playedCardCount = 0;
       59:  187:	state->whoseTurn = 0;
       59:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      354:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      295:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       59:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       59:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 360 returned 100% blocks executed 100%
      360:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      360:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      360:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      242:  210:		return -1;
      118:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1416:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1180:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1180:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1180:  217:		newDeckPos++;
     4779:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3599:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1180:  221:		state->deckCount[player]--;
        -:  222:	}
     1298:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1180:  224:		state->deck[player][i] = newDeck[i];
     1180:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      118:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 264 returned 100% blocks executed 100%
      264:  349:int whoseTurn(struct gameState *state) {
      264:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 992 returned 100% blocks executed 88%
      992:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      992:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      242:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      242:  542:		state->deckCount[player] = state->discardCount[player];
      242:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      242:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      242:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      242:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      242:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      242:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      242:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      242:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      242:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      750:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      750:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      750:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      750:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      750:  580:		state->deckCount[player]--;
      750:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      750:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 42 returned 100% blocks executed 69%
       42:  650:int playAdventurer(struct gameState *state) {
       42:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       42:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       42:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      168:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       84:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       84:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       84:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       84:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       84:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       84:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       42:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 25 returned 100% blocks executed 100%
       25:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       25:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      125:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      100:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       25:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       75:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       50:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       25:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       25:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       25:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 84 returned 100% blocks executed 100%
       84:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       84:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      504:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      420:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       84:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       84:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 211 returned 100% blocks executed 78%
      211: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      211: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      200: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      200: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      211: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      211: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      211: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      211: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      211: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      211: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      211: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 59 returned 100% blocks executed 82%
       59: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       59: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      354: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      295: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      236: 1357:			state->coins += 1;
        -: 1358:		}
       59: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       59: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       59: 1370:	state->coins += bonus;
        -: 1371:
       59: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playCouncilRoom(gameState*, int) <<<
 playCouncilRoom increases hand count by 4 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 0
Expected number of cards in hand: 8 	Actual number of cards in hand: 8

 >>> TESTING - playCouncilRoom(gameState*, int) <<<
 playCouncilRoom increases opponent's hand by 1
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 0
Expected number of cards in hand: 1 	Actual number of cards in hand: 1

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:92
        -:    0:Programs:91
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1800 returned 100% blocks executed 83%
     1800:    8:int compare(const void* a, const void* b) {
     1800:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1800:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      480:   12:		return -1;
     1320:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 60 returned 100% blocks executed 88%
       60:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       60:   44:	SelectStream(1);
call    0 returned 100%
       60:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       60:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       60:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      660:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6600:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6000:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       60:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       60:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       60:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       60:   89:		state->supplyCount[estate] = 8;
       60:   90:		state->supplyCount[duchy] = 8;
       60:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       60:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       60:  102:	state->supplyCount[silver] = 40;
       60:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1260:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
     9900:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9300:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      600:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      120:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       60:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      540:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      600:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8700:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      180:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      120:  140:		state->deckCount[i] = 0;
      480:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      360:  143:			state->deck[i][j] = estate;
      360:  144:			state->deckCount[i]++;
        -:  145:		}
      960:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      840:  148:			state->deck[i][j] = copper;
      840:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      180:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      120:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      180:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      120:  166:		state->handCount[i] = 0;
      120:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1680:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1620:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       60:  182:	state->outpostPlayed = 0;
       60:  183:	state->phase = 0;
       60:  184:	state->numActions = 1;
       60:  185:	state->numBuys = 1;
       60:  186:	state->playedCardCount = 0;
       60:  187:	state->whoseTurn = 0;
       60:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      360:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      300:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       60:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       60:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 362 returned 100% blocks executed 100%
      362:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      362:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      362:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      242:  210:		return -1;
      120:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1440:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1200:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1200:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1200:  217:		newDeckPos++;
     4860:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3660:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1200:  221:		state->deckCount[player]--;
        -:  222:	}
     1320:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1200:  224:		state->deck[player][i] = newDeck[i];
     1200:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      120:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 266 returned 100% blocks executed 100%
      266:  349:int whoseTurn(struct gameState *state) {
      266:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1007 returned 100% blocks executed 88%
     1007:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1007:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      242:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      242:  542:		state->deckCount[player] = state->discardCount[player];
      242:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      242:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      242:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      242:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      242:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      242:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      242:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      242:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      242:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      765:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      765:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      765:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      765:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      765:  580:		state->deckCount[player]--;
      765:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      765:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 42 returned 100% blocks executed 69%
       42:  650:int playAdventurer(struct gameState *state) {
       42:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       42:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       42:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      168:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       84:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       84:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       84:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       84:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       84:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       84:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       42:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 27 returned 100% blocks executed 100%
       27:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       27:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      135:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      108:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       27:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       81:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       54:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       27:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       27:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       27:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 84 returned 100% blocks executed 100%
       84:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       84:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      504:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      420:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       84:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       84:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 213 returned 100% blocks executed 78%
      213: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      213: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      202: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      202: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      213: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      213: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      213: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      213: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      213: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      213: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      213: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 60 returned 100% blocks executed 82%
       60: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       60: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      360: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      300: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      240: 1357:			state->coins += 1;
        -: 1358:		}
       60: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       60: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       60: 1370:	state->coins += bonus;
        -: 1371:
       60: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 9
Expected number of cards in hand: 7 	Actual number of cards in hand: 9
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 7 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy decreases deck count by 3 (when deck has 3 cards)
Current hand count: 5
Current hand count: 6
Current hand count: 7
Deck count now: 0
Current hand count: 8
Deck count now: 0
Current hand count: 8
Expected number of cards in deck: 0 	Actual number of cards in deck: 0

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy - player's deck count is >= 0 when decreased by 3 (when deck has < 3 cards)
Current hand count: 5
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Number of cards in deck: 0

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:93
        -:    0:Programs:92
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1800 returned 100% blocks executed 83%
     1800:    8:int compare(const void* a, const void* b) {
     1800:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1800:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      480:   12:		return -1;
     1320:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 60 returned 100% blocks executed 88%
       60:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       60:   44:	SelectStream(1);
call    0 returned 100%
       60:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       60:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       60:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      660:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6600:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6000:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       60:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       60:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       60:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       60:   89:		state->supplyCount[estate] = 8;
       60:   90:		state->supplyCount[duchy] = 8;
       60:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       60:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       60:  102:	state->supplyCount[silver] = 40;
       60:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1260:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
     9900:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9300:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      600:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      120:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       60:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      540:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      600:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8700:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      180:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      120:  140:		state->deckCount[i] = 0;
      480:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      360:  143:			state->deck[i][j] = estate;
      360:  144:			state->deckCount[i]++;
        -:  145:		}
      960:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      840:  148:			state->deck[i][j] = copper;
      840:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      180:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      120:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      180:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      120:  166:		state->handCount[i] = 0;
      120:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1680:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1620:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       60:  182:	state->outpostPlayed = 0;
       60:  183:	state->phase = 0;
       60:  184:	state->numActions = 1;
       60:  185:	state->numBuys = 1;
       60:  186:	state->playedCardCount = 0;
       60:  187:	state->whoseTurn = 0;
       60:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      360:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      300:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       60:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       60:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 373 returned 100% blocks executed 100%
      373:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      373:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      373:  209:	if (state->deckCount[player] < 1)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
      253:  210:		return -1;
      120:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1440:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1200:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1200:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1200:  217:		newDeckPos++;
     4860:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3660:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1200:  221:		state->deckCount[player]--;
        -:  222:	}
     1320:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1200:  224:		state->deck[player][i] = newDeck[i];
     1200:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      120:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 270 returned 100% blocks executed 100%
      270:  349:int whoseTurn(struct gameState *state) {
      270:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1027 returned 100% blocks executed 88%
     1027:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1027:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      253:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      253:  542:		state->deckCount[player] = state->discardCount[player];
      253:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      253:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      253:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      253:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      253:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      253:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      253:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      253:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      253:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      774:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      774:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      774:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      774:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      774:  580:		state->deckCount[player]--;
      774:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      774:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 42 returned 100% blocks executed 69%
       42:  650:int playAdventurer(struct gameState *state) {
       42:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       42:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       42:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      168:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       84:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       84:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       84:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       84:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       84:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       84:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       42:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 27 returned 100% blocks executed 100%
       27:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       27:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      135:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      108:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       27:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       81:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       54:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       27:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       27:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       27:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 88 returned 100% blocks executed 100%
       88:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       88:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      528:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      440:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       88:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       88:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 217 returned 100% blocks executed 78%
      217: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      217: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      206: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      206: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      217: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      217: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      217: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      217: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      217: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      217: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      217: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 60 returned 100% blocks executed 82%
       60: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       60: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      360: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      300: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      240: 1357:			state->coins += 1;
        -: 1358:		}
       60: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       60: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       60: 1370:	state->coins += bonus;
        -: 1371:
       60: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand count by 2 and discards the card
Current hand count: 5
Current hand count: 6
Expected number of cards in hand: 6 	Actual number of cards in hand: 7
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand TREASURE count by 2
Current hand count: 5
Current hand count: 6
Expected number of treasures in hand: 6 	Actual number of treasures in hand: 4
TEST FAILED: treasure count incorrect after playing adventurer.

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:94
        -:    0:Programs:93
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1830 returned 100% blocks executed 83%
     1830:    8:int compare(const void* a, const void* b) {
     1830:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1830:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      488:   12:		return -1;
     1342:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 61 returned 100% blocks executed 88%
       61:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       61:   44:	SelectStream(1);
call    0 returned 100%
       61:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       61:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       61:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      671:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6710:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6100:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       61:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       61:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       61:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       61:   89:		state->supplyCount[estate] = 8;
       61:   90:		state->supplyCount[duchy] = 8;
       61:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       61:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       61:  102:	state->supplyCount[silver] = 40;
       61:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1281:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
    10065:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9455:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      610:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      122:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       61:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      549:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      610:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8845:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      183:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      122:  140:		state->deckCount[i] = 0;
      488:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      366:  143:			state->deck[i][j] = estate;
      366:  144:			state->deckCount[i]++;
        -:  145:		}
      976:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      854:  148:			state->deck[i][j] = copper;
      854:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      183:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      122:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      183:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      122:  166:		state->handCount[i] = 0;
      122:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1708:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1647:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       61:  182:	state->outpostPlayed = 0;
       61:  183:	state->phase = 0;
       61:  184:	state->numActions = 1;
       61:  185:	state->numBuys = 1;
       61:  186:	state->playedCardCount = 0;
       61:  187:	state->whoseTurn = 0;
       61:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      366:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      305:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       61:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       61:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 375 returned 100% blocks executed 100%
      375:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      375:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      375:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      253:  210:		return -1;
      122:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1464:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1220:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1220:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1220:  217:		newDeckPos++;
     4941:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3721:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1220:  221:		state->deckCount[player]--;
        -:  222:	}
     1342:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1220:  224:		state->deck[player][i] = newDeck[i];
     1220:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      122:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 272 returned 100% blocks executed 100%
      272:  349:int whoseTurn(struct gameState *state) {
      272:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1036 returned 100% blocks executed 88%
     1036:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1036:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      253:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      253:  542:		state->deckCount[player] = state->discardCount[player];
      253:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      253:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      253:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      253:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      253:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      253:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      253:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      253:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      253:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      783:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      783:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      783:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      783:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      783:  580:		state->deckCount[player]--;
      783:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      783:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 44 returned 100% blocks executed 69%
       44:  650:int playAdventurer(struct gameState *state) {
       44:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       44:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       44:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      176:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       88:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       88:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       88:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       88:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       88:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       88:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       44:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 27 returned 100% blocks executed 100%
       27:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       27:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      135:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      108:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       27:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       81:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       54:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       27:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       27:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       27:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 88 returned 100% blocks executed 100%
       88:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       88:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      528:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      440:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       88:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       88:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 36 returned 100% blocks executed 6%
       36:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       36:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       36:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       36:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       36:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       36:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       13:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       13:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       13:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       13:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 217 returned 100% blocks executed 78%
      217: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      217: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      206: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      206: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      217: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      217: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      217: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      217: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      217: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      217: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      217: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 61 returned 100% blocks executed 82%
       61: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       61: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      366: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      305: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      244: 1357:			state->coins += 1;
        -: 1358:		}
       61: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       61: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       61: 1370:	state->coins += bonus;
        -: 1371:
       61: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - cardEffect() for great_hall <<<
 great_hall increases hand count by 1 and discards the card
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:95
        -:    0:Programs:94
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1860 returned 100% blocks executed 83%
     1860:    8:int compare(const void* a, const void* b) {
     1860:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1860:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      496:   12:		return -1;
     1364:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 62 returned 100% blocks executed 88%
       62:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       62:   44:	SelectStream(1);
call    0 returned 100%
       62:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       62:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       62:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      682:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6820:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6200:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       62:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       62:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       62:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       62:   89:		state->supplyCount[estate] = 8;
       62:   90:		state->supplyCount[duchy] = 8;
       62:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       62:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       62:  102:	state->supplyCount[silver] = 40;
       62:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1302:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
    10230:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9610:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      620:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      124:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       62:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      558:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      620:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     8990:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      186:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      124:  140:		state->deckCount[i] = 0;
      496:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      372:  143:			state->deck[i][j] = estate;
      372:  144:			state->deckCount[i]++;
        -:  145:		}
      992:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      868:  148:			state->deck[i][j] = copper;
      868:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      186:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      124:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      186:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      124:  166:		state->handCount[i] = 0;
      124:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1736:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1674:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       62:  182:	state->outpostPlayed = 0;
       62:  183:	state->phase = 0;
       62:  184:	state->numActions = 1;
       62:  185:	state->numBuys = 1;
       62:  186:	state->playedCardCount = 0;
       62:  187:	state->whoseTurn = 0;
       62:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      372:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      310:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       62:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       62:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 377 returned 100% blocks executed 100%
      377:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      377:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      377:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      253:  210:		return -1;
      124:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1488:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1240:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1240:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1240:  217:		newDeckPos++;
     5022:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3782:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1240:  221:		state->deckCount[player]--;
        -:  222:	}
     1364:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1240:  224:		state->deck[player][i] = newDeck[i];
     1240:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      124:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 22 returned 100% blocks executed 100%
       22:  318:int handCard(int handPos, struct gameState *state) {
       22:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       22:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 273 returned 100% blocks executed 100%
      273:  349:int whoseTurn(struct gameState *state) {
      273:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1042 returned 100% blocks executed 88%
     1042:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1042:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      253:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      253:  542:		state->deckCount[player] = state->discardCount[player];
      253:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      253:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      253:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      253:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      253:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      253:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      253:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      253:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      253:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      789:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      789:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      789:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      789:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      789:  580:		state->deckCount[player]--;
      789:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      789:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 22 returned 100% blocks executed 10%
       22:  587:int getCost(int cardNumber)
        -:  588:{
       22:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 44 returned 100% blocks executed 69%
       44:  650:int playAdventurer(struct gameState *state) {
       44:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       44:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       44:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      176:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       88:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       88:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       88:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       88:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       88:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       88:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       44:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 27 returned 100% blocks executed 100%
       27:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       27:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      135:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      108:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       27:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       81:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       54:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       27:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       27:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       27:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 88 returned 100% blocks executed 100%
       88:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       88:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      528:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      440:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       88:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       88:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 37 returned 100% blocks executed 6%
       37:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       37:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       37:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       37:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       37:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       37:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 38%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 62%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       14:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       14:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       14:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       14:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       23: 1212:		state->numBuys++;
        -: 1213:
       23: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       11: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       11: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       23: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       23: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 218 returned 100% blocks executed 78%
      218: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      218: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      207: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      207: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      218: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      218: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      218: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      218: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      218: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      218: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      218: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 62 returned 100% blocks executed 82%
       62: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       62: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      372: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      310: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      248: 1357:			state->coins += 1;
        -: 1358:		}
       62: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       62: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       62: 1370:	state->coins += bonus;
        -: 1371:
       62: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - cardEffect() for salvager <<<
 salvager increases buy count by 1
Expected number of buys: 2 	Actual number of buys: 2

 >>> TESTING - cardEffect() for salvager <<<
 salvager increases coins by cost of trashed card
Expected number of coins: 4 	Actual number of coins: 4

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:96
        -:    0:Programs:95
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1890 returned 100% blocks executed 83%
     1890:    8:int compare(const void* a, const void* b) {
     1890:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     1890:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      504:   12:		return -1;
     1386:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 63 returned 100% blocks executed 88%
       63:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       63:   44:	SelectStream(1);
call    0 returned 100%
       63:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       63:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       63:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      693:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     6930:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6300:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       63:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       63:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       63:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       63:   89:		state->supplyCount[estate] = 8;
       63:   90:		state->supplyCount[duchy] = 8;
       63:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       63:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       63:  102:	state->supplyCount[silver] = 40;
       63:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1323:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
    10395:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
     9765:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      630:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      126:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       63:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      567:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      630:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     9135:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      189:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      126:  140:		state->deckCount[i] = 0;
      504:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      378:  143:			state->deck[i][j] = estate;
      378:  144:			state->deckCount[i]++;
        -:  145:		}
     1008:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      882:  148:			state->deck[i][j] = copper;
      882:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      189:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      126:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      189:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      126:  166:		state->handCount[i] = 0;
      126:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1764:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1701:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       63:  182:	state->outpostPlayed = 0;
       63:  183:	state->phase = 0;
       63:  184:	state->numActions = 1;
       63:  185:	state->numBuys = 1;
       63:  186:	state->playedCardCount = 0;
       63:  187:	state->whoseTurn = 0;
       63:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      378:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      315:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       63:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       63:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 379 returned 100% blocks executed 100%
      379:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      379:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      379:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      253:  210:		return -1;
      126:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1512:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1260:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1260:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1260:  217:		newDeckPos++;
     5103:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     3843:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1260:  221:		state->deckCount[player]--;
        -:  222:	}
     1386:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1260:  224:		state->deck[player][i] = newDeck[i];
     1260:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      126:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 24 returned 100% blocks executed 100%
       24:  318:int handCard(int handPos, struct gameState *state) {
       24:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       24:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 277 returned 100% blocks executed 100%
      277:  349:int whoseTurn(struct gameState *state) {
      277:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1047 returned 100% blocks executed 88%
     1047:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1047:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      253:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      253:  542:		state->deckCount[player] = state->discardCount[player];
      253:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      253:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      253:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      253:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      253:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      253:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      253:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      253:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      253:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      794:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      794:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      794:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      794:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      794:  580:		state->deckCount[player]--;
      794:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      794:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 24 returned 100% blocks executed 10%
       24:  587:int getCost(int cardNumber)
        -:  588:{
       24:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       24:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 44 returned 100% blocks executed 69%
       44:  650:int playAdventurer(struct gameState *state) {
       44:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       44:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       44:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      176:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       88:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       88:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       88:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       88:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       88:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       88:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       44:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 27 returned 100% blocks executed 100%
       27:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       27:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      135:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      108:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       27:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       81:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       54:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       27:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       27:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       27:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 88 returned 100% blocks executed 100%
       88:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       88:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      528:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      440:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       88:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       88:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 55 returned 100% blocks executed 100%
       55:  751:int playVillage(struct gameState *state, int handPos) {
       55:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       55:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       55:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       55:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       55:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 39 returned 100% blocks executed 6%
       39:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       39:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       39:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       39:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       39:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       39:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       14:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       14:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       14:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       14:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       25: 1212:		state->numBuys++;
        -: 1213:
       25: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       12: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       12: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       25: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       25: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 221 returned 100% blocks executed 78%
      221: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      221: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      209: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      209: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      221: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      221: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      221: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      221: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      221: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      221: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      221: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 63 returned 100% blocks executed 82%
       63: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       63: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      378: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      315: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      252: 1357:			state->coins += 1;
        -: 1358:		}
       63: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       63: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       63: 1370:	state->coins += bonus;
        -: 1371:
       63: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases actions by 2
Current hand count: 5
Expected number of actions: 3 	Actual number actions: 4
TEST FAILED: action count incorrect.

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage decreases deck count by 1
Current hand count: 5
Expected number of cards in deck: 9 	Actual number of cards in deck: 9

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playVillage(gameState*, int) <<<
 playVillage increases hand count by 1 and discards the card when deck count is 1
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>>>> SUCCESS: Testing complete <<<<<


 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 9
Expected number of cards in hand: 7 	Actual number of cards in hand: 9
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 7 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy decreases deck count by 3 (when deck has 3 cards)
Current hand count: 5
Current hand count: 6
Current hand count: 7
Deck count now: 0
Current hand count: 8
Deck count now: 0
Current hand count: 8
Expected number of cards in deck: 0 	Actual number of cards in deck: 0

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy - player's deck count is >= 0 when decreased by 3 (when deck has < 3 cards)
Current hand count: 5
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Number of cards in deck: 0

 >>>>> SUCCESS: Testing complete <<<<<

Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand count by 2 and discards the card
Current hand count: 5
Current hand count: 6
Expected number of cards in hand: 6 	Actual number of cards in hand: 7
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand TREASURE count by 2
Current hand count: 5
Current hand count: 6
Expected number of treasures in hand: 6 	Actual number of treasures in hand: 4
TEST FAILED: treasure count incorrect after playing adventurer.

 >>>>> SUCCESS: Testing complete <<<<<

Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playCouncilRoom(gameState*, int) <<<
 playCouncilRoom increases hand count by 4 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 0
Expected number of cards in hand: 8 	Actual number of cards in hand: 8

 >>> TESTING - playCouncilRoom(gameState*, int) <<<
 playCouncilRoom increases opponent's hand by 1
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 0
Expected number of cards in hand: 1 	Actual number of cards in hand: 1

 >>>>> SUCCESS: Testing complete <<<<<


 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card
Current hand count: 5
Current hand count: 6
Current hand count: 7
Current hand count: 8
Current hand count: 9
Expected number of cards in hand: 7 	Actual number of cards in hand: 9
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy increases hand count by 3 and discards the card when deck count is 0
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Deck count now: 0
Current hand count: 5
Expected number of cards in hand: 7 	Actual number of cards in hand: 4
TEST FAILED: hand count incorrect after drawing/discarding when deck count is 0.

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy decreases deck count by 3 (when deck has 3 cards)
Current hand count: 5
Current hand count: 6
Current hand count: 7
Deck count now: 0
Current hand count: 8
Deck count now: 0
Current hand count: 8
Expected number of cards in deck: 0 	Actual number of cards in deck: 0

 >>> TESTING - playSmithy(gameState*, int) <<<
 playSmithy - player's deck count is >= 0 when decreased by 3 (when deck has < 3 cards)
Current hand count: 5
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Deck count now: 0
Current hand count: 6
Number of cards in deck: 0

 >>>>> SUCCESS: Testing complete <<<<<

Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand count by 2 and discards the card
Current hand count: 5
Current hand count: 6
Expected number of cards in hand: 6 	Actual number of cards in hand: 7
TEST FAILED: hand count incorrect after drawing/discarding.

 >>> TESTING - playAdventurer(gameState*) <<<
 playAdventurer increases hand TREASURE count by 2
Current hand count: 5
Current hand count: 6
Expected number of treasures in hand: 6 	Actual number of treasures in hand: 4
TEST FAILED: treasure count incorrect after playing adventurer.

 >>>>> SUCCESS: Testing complete <<<<<

Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - cardEffect() for great_hall <<<
 great_hall increases hand count by 1 and discards the card
Current hand count: 5
Expected number of cards in hand: 5 	Actual number of cards in hand: 5

 >>>>> SUCCESS: Testing complete <<<<<

Current hand count: 0
Current hand count: 1
Current hand count: 2
Current hand count: 3
Current hand count: 4

 >>> TESTING - cardEffect() for salvager <<<
 salvager increases buy count by 1
Expected number of buys: 2 	Actual number of buys: 2

 >>> TESTING - cardEffect() for salvager <<<
 salvager increases coins by cost of trashed card
Expected number of coins: 4 	Actual number of coins: 4

 >>>>> SUCCESS: Testing complete <<<<<

Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:84.62% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:7.48% of 214
Branches executed:14.45% of 173
Taken at least once:2.89% of 173
Calls executed:10.45% of 67

Function 'playVillage'
Lines executed:100.00% of 6
No branches
Calls executed:100.00% of 3

Function 'playSmithy'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 3

Function 'playRemodel'
Lines executed:0.00% of 12
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 6

Function 'playCouncilRoom'
Lines executed:100.00% of 10
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
Calls executed:100.00% of 4

Function 'playAdventurer'
Lines executed:66.67% of 18
Branches executed:66.67% of 12
Taken at least once:41.67% of 12
Calls executed:66.67% of 3

Function 'getCost'
Lines executed:10.00% of 30
Branches executed:100.00% of 28
Taken at least once:3.57% of 28
No calls

Function 'drawCard'
Lines executed:80.00% of 25
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
Calls executed:100.00% of 4

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 3
No branches
Calls executed:100.00% of 1

Function 'numHandCards'
Lines executed:0.00% of 2
No branches
Calls executed:0.00% of 1

Function 'buyCard'
Lines executed:0.00% of 18
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 10

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:100.00% of 16
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:83.87% of 62
Branches executed:95.65% of 46
Taken at least once:78.26% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:29.18% of 586
Branches executed:34.77% of 417
Taken at least once:19.18% of 417
Calls executed:25.62% of 121
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:104
        -:    0:Programs:103
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 2040 returned 100% blocks executed 83%
     2040:    8:int compare(const void* a, const void* b) {
     2040:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
     2040:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      544:   12:		return -1;
     1496:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
    #####:   23:	int* k = malloc(10 * sizeof(int));
    #####:   24:	k[0] = k1;
    #####:   25:	k[1] = k2;
    #####:   26:	k[2] = k3;
    #####:   27:	k[3] = k4;
    #####:   28:	k[4] = k5;
    #####:   29:	k[5] = k6;
    #####:   30:	k[6] = k7;
    #####:   31:	k[7] = k8;
    #####:   32:	k[8] = k9;
    #####:   33:	k[9] = k10;
    #####:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 68 returned 100% blocks executed 88%
       68:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:	struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       68:   44:	SelectStream(1);
call    0 returned 100%
       68:   45:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:
        -:   47:	//check number of players
       68:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       68:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      748:   57:	for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:	{
     7480:   59:		for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:		{
     6800:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       68:   73:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:	{
       68:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       68:   87:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:	{
       68:   89:		state->supplyCount[estate] = 8;
       68:   90:		state->supplyCount[duchy] = 8;
       68:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       68:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       68:  102:	state->supplyCount[silver] = 40;
       68:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
     1428:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:	{
    11220:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:		{
    10540:  110:			if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      680:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  114:				{
      136:  115:					if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       68:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else { state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
      612:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      680:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     9860:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
      204:  138:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:	{
      136:  140:		state->deckCount[i] = 0;
      544:  141:		for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:		{
      408:  143:			state->deck[i][j] = estate;
      408:  144:			state->deckCount[i]++;
        -:  145:		}
     1088:  146:		for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:		{
      952:  148:			state->deck[i][j] = copper;
      952:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
      204:  154:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:	{
      136:  156:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
      204:  163:	for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:	{
        -:  165:		//initialize hand size to zero
      136:  166:		state->handCount[i] = 0;
      136:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
     1904:  176:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:	{
     1836:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       68:  182:	state->outpostPlayed = 0;
       68:  183:	state->phase = 0;
       68:  184:	state->numActions = 1;
       68:  185:	state->numBuys = 1;
       68:  186:	state->playedCardCount = 0;
       68:  187:	state->whoseTurn = 0;
       68:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
      408:  192:	for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      340:  193:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:	}
        -:  195:
       68:  196:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
       68:  198:	return 0;
        -:  199:}
        -:  200:
function shuffle called 412 returned 100% blocks executed 100%
      412:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      412:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      412:  209:	if (state->deckCount[player] < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      276:  210:		return -1;
      136:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1632:  214:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1360:  215:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1360:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1360:  217:		newDeckPos++;
     5508:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
     4148:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1360:  221:		state->deckCount[player]--;
        -:  222:	}
     1496:  223:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1360:  224:		state->deck[player][i] = newDeck[i];
     1360:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      136:  228:	return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
    #####:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
    #####:  237:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
    #####:  243:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
call    0 never executed
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG) {
    #####:  275:		printf("Entering buyCard...\n");
call    0 never executed
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
    #####:  280:	who = state->whoseTurn;
        -:  281:
    #####:  282:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  283:		if (DEBUG)
    #####:  284:			printf("You do not have any buys left\n");
call    0 never executed
    #####:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:		if (DEBUG)
    #####:  289:			printf("There are not any of that type of card left\n");
call    0 never executed
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:		if (DEBUG)
    #####:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
call    0 never executed
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
    #####:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
call    0 never executed
call    1 never executed
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
call    0 never executed
        -:  316:}
        -:  317:
function handCard called 26 returned 100% blocks executed 100%
       26:  318:int handCard(int handPos, struct gameState *state) {
       26:  319:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       26:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
function whoseTurn called 301 returned 100% blocks executed 100%
      301:  349:int whoseTurn(struct gameState *state) {
      301:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
    #####:  356:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  357:
        -:  358:	//Discard hand
    #####:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
    #####:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
    #####:  366:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else {
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
    #####:  373:	state->outpostPlayed = 0;
    #####:  374:	state->phase = 0;
    #####:  375:	state->numActions = 1;
    #####:  376:	state->coins = 0;
    #####:  377:	state->numBuys = 1;
    #####:  378:	state->playedCardCount = 0;
    #####:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
    #####:  383:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  384:		drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  385:	}
        -:  386:
        -:  387:	//Update money
    #####:  388:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  389:
    #####:  390:	return 0;
        -:  391:}
        -:  392:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
branch  0 never executed
branch  1 never executed
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
function drawCard called 1136 returned 100% blocks executed 88%
     1136:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1136:  532:	if (state->deckCount[player] <= 0) {//Deck is empty
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  533:
        -:  534:	  //Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      276:  537:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      276:  542:		state->deckCount[player] = state->discardCount[player];
      276:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      276:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  547:
        -:  548:		if (DEBUG) {//Debug statements
      276:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
call    0 returned 100%
        -:  550:		}
        -:  551:
      276:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      276:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG) {//Debug statements
      276:  558:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  559:		}
        -:  560:
      276:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      276:  563:		if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      276:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else {
      860:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG) {//Debug statements
      860:  575:			printf("Current hand count: %d\n", count);
call    0 returned 100%
        -:  576:		}
        -:  577:
      860:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      860:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      860:  580:		state->deckCount[player]--;
      860:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      860:  584:	return 0;
        -:  585:}
        -:  586:
function getCost called 26 returned 100% blocks executed 10%
       26:  587:int getCost(int cardNumber)
        -:  588:{
       26:  589:	switch (cardNumber)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
       26:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
function playAdventurer called 48 returned 100% blocks executed 69%
       48:  650:int playAdventurer(struct gameState *state) {
       48:  651:	int drawntreasure = 0;
        -:  652:	int cardDrawn;
        -:  653:	int temphand[MAX_HAND];
       48:  654:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       48:  655:	int z = 0;// this is the counter for the temp hand
        -:  656:	
      192:  657:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       96:  658:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  659:			shuffle(currentPlayer, state);
call    0 never executed
        -:  660:		}
       96:  661:		drawCard(currentPlayer, state);
call    0 returned 100%
       96:  662:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       96:  663:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
       96:  664:			drawntreasure++;
        -:  665:		else {
    #####:  666:			temphand[z] = cardDrawn;
    #####:  667:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  668:			z++;
        -:  669:		}
        -:  670:	}
       96:  671:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  672:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  673:		z = z + 1;
        -:  674:	}
       48:  675:	return 0;
        -:  676:}
        -:  677:
function playCouncilRoom called 29 returned 100% blocks executed 100%
       29:  678:int playCouncilRoom(struct gameState *state, int handPos) {
        -:  679:	int i;
       29:  680:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  681:
        -:  682:	//+4 Cards
      145:  683:	for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  684:	{
      116:  685:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  686:	}
        -:  687:
        -:  688:	//+1 Buy
       29:  689:	state->numBuys++;
        -:  690:
        -:  691:	//Each other player draws a card
       87:  692:	for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  693:	{
       58:  694:		if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  695:		{
       29:  696:			drawCard(i, state);
call    0 returned 100%
        -:  697:		}
        -:  698:	}
        -:  699:
        -:  700:	//put played card in played card pile
       29:  701:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  702:
       29:  703:	return 0;
        -:  704:}
        -:  705:
function playRemodel called 0 returned 0% blocks executed 0%
    #####:  706:int playRemodel(struct gameState *state, int choice1, int choice2, int handPos) {
        -:  707:	int i;
        -:  708:	int j;
    #####:  709:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  710:
    #####:  711:	j = state->hand[currentPlayer][choice2];  //store card we will trash
        -:  712:
    #####:  713:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  714:	{
    #####:  715:		return -1;
        -:  716:	}
        -:  717:
    #####:  718:	gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  719:
        -:  720:	//discard card from hand
    #####:  721:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:
        -:  723:	//discard trashed card
    #####:  724:	for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  725:	{
    #####:  726:		if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  727:		{
    #####:  728:			discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  729:			break;
        -:  730:		}
        -:  731:	}
        -:  732:
    #####:  733:	return 0;
        -:  734:}
        -:  735:
function playSmithy called 96 returned 100% blocks executed 100%
       96:  736:int playSmithy(struct gameState *state, int handPos) {
        -:  737:	int i;
       96:  738:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  739:
        -:  740:	//+3 Cards
      576:  741:	for (i = 0; i < 5; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  742:	{
      480:  743:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  744:	}
        -:  745:
        -:  746:	//discard card from hand
       96:  747:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       96:  748:	return 0;
        -:  749:}
        -:  750:
function playVillage called 60 returned 100% blocks executed 100%
       60:  751:int playVillage(struct gameState *state, int handPos) {
       60:  752:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  753:
        -:  754:	//+1 Card
       60:  755:	drawCard(currentPlayer, state);
call    0 returned 100%
        -:  756:
        -:  757:	//+2 Actions
       60:  758:	state->numActions = state->numActions + 3;
        -:  759:
        -:  760:	//discard played card from hand
       60:  761:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       60:  762:	return 0;
        -:  763:}
        -:  764:
function cardEffect called 42 returned 100% blocks executed 6%
       42:  765:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  766:{
        -:  767:	int i;
        -:  768:	int j;
        -:  769:	int k;
        -:  770:	int x;
        -:  771:	int index;
       42:  772:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
       42:  773:	int nextPlayer = currentPlayer + 1;
        -:  774:
       42:  775:	int tributeRevealedCards[2] = { -1, -1 };
        -:  776:	int temphand[MAX_HAND];// moved above the if statement
        -:  777:	
       42:  778:	if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:		nextPlayer = 0;
        -:  780:	}
        -:  781:
        -:  782:
        -:  783:	//uses switch to select card and perform actions
       42:  784:	switch (card)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 36%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 64%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  785:	{
        -:  786:	case adventurer:
    #####:  787:		playAdventurer(state);
call    0 never executed
    #####:  788:		break;
        -:  789:
        -:  790:	case council_room:
    #####:  791:		playCouncilRoom(state, handPos);
call    0 never executed
    #####:  792:		break;
        -:  793:
        -:  794:	case feast:
        -:  795:		//gain card with cost up to 5
        -:  796:		//Backup hand
    #####:  797:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  798:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:		}
        -:  801:		//Backup hand
        -:  802:
        -:  803:		//Update Coins for Buy
    #####:  804:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:		x = 1;//Condition to loop on
    #####:  806:		while (x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				if (DEBUG)
    #####:  809:					printf("None of that card left, sorry!\n");
call    0 never executed
        -:  810:
        -:  811:				if (DEBUG) {
    #####:  812:					printf("Cards Left: %d\n", supplyCount(choice1, state));
call    0 never executed
call    1 never executed
        -:  813:				}
        -:  814:			}
    #####:  815:			else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:				printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:				if (DEBUG) {
    #####:  819:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
call    0 never executed
call    1 never executed
        -:  820:				}
        -:  821:			}
        -:  822:			else {
        -:  823:
        -:  824:				if (DEBUG) {
    #####:  825:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  826:				}
        -:  827:
    #####:  828:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:				x = 0;//No more buying cards
        -:  830:
        -:  831:				if (DEBUG) {
    #####:  832:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
call    0 never executed
        -:  833:				}
        -:  834:
        -:  835:			}
        -:  836:		}
        -:  837:
        -:  838:		//Reset Hand
    #####:  839:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  840:			state->hand[currentPlayer][i] = temphand[i];
    #####:  841:			temphand[i] = -1;
        -:  842:		}
        -:  843:		//Reset Hand
        -:  844:
    #####:  845:		return 0;
        -:  846:
        -:  847:	case gardens:
    #####:  848:		return -1;
        -:  849:
        -:  850:	case mine:
    #####:  851:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:		{
    #####:  855:			return -1;
        -:  856:		}
        -:  857:
    #####:  858:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:		{
    #####:  860:			return -1;
        -:  861:		}
        -:  862:
    #####:  863:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:		{
    #####:  865:			return -1;
        -:  866:		}
        -:  867:
    #####:  868:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:		//discard card from hand
    #####:  871:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:		//discard trashed card
    #####:  874:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:		{
    #####:  876:			if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:			{
    #####:  878:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  879:				break;
        -:  880:			}
        -:  881:		}
        -:  882:
    #####:  883:		return 0;
        -:  884:
        -:  885:	case remodel:
    #####:  886:		playRemodel(state, choice1, choice2, handPos);
call    0 never executed
    #####:  887:		break;
        -:  888:
        -:  889:	case smithy:
    #####:  890:		playSmithy(state, handPos);
call    0 never executed
    #####:  891:		break;
        -:  892:		
        -:  893:	case village:
    #####:  894:		playVillage(state, handPos);
call    0 never executed
    #####:  895:		break;
        -:  896:		
        -:  897:	case baron:
    #####:  898:		state->numBuys++;//Increase buys by 1!
    #####:  899:		if (choice1 > 0) {//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  900:			int p = 0;//Iterator for hand!
    #####:  901:			int card_not_discarded = 1;//Flag for discard set!
    #####:  902:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  903:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  904:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  905:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  906:					state->discardCount[currentPlayer]++;
    #####:  907:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  908:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  909:					}
    #####:  910:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  911:					state->handCount[currentPlayer]--;
    #####:  912:					card_not_discarded = 0;//Exit the loop
        -:  913:				}
    #####:  914:				else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  915:					if (DEBUG) {
    #####:  916:						printf("No estate cards in your hand, invalid choice\n");
call    0 never executed
    #####:  917:						printf("Must gain an estate if there are any\n");
call    0 never executed
        -:  918:					}
    #####:  919:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  921:						state->supplyCount[estate]--;//Decrement estates
    #####:  922:						if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:							isGameOver(state);
call    0 never executed
        -:  924:						}
        -:  925:					}
    #####:  926:					card_not_discarded = 0;//Exit the loop
        -:  927:				}
        -:  928:
        -:  929:				else {
    #####:  930:					p++;//Next card
        -:  931:				}
        -:  932:			}
        -:  933:		}
        -:  934:
        -:  935:		else {
    #####:  936:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  937:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  938:				state->supplyCount[estate]--;//Decrement Estates
    #####:  939:				if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:					isGameOver(state);
call    0 never executed
        -:  941:				}
        -:  942:			}
        -:  943:		}
        -:  944:
        -:  945:
    #####:  946:		return 0;
        -:  947:
        -:  948:	case great_hall:
        -:  949:		//+1 Card
       15:  950:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  951:
        -:  952:		//+1 Actions
       15:  953:		state->numActions++;
        -:  954:
        -:  955:		//discard card from hand
       15:  956:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       15:  957:		return 0;
        -:  958:
        -:  959:	case minion:
        -:  960:		//+1 action
    #####:  961:		state->numActions++;
        -:  962:
        -:  963:		//discard card from hand
    #####:  964:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  965:
    #####:  966:		if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  967:		{
    #####:  968:			state->coins = state->coins + 2;
        -:  969:		}
        -:  970:
    #####:  971:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  972:		{
        -:  973:			//discard hand
    #####:  974:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  975:			{
    #####:  976:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  977:			}
        -:  978:
        -:  979:			//draw 4
    #####:  980:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  981:			{
    #####:  982:				drawCard(currentPlayer, state);
call    0 never executed
        -:  983:			}
        -:  984:
        -:  985:			//other players discard hand and redraw if hand size > 4
    #####:  986:			for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  987:			{
    #####:  988:				if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  989:				{
    #####:  990:					if (state->handCount[i] > 4)
branch  0 never executed
branch  1 never executed
        -:  991:					{
        -:  992:						//discard hand
    #####:  993:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
        -:  994:						{
    #####:  995:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  996:						}
        -:  997:
        -:  998:						//draw 4
    #####:  999:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1000:						{
    #####: 1001:							drawCard(i, state);
call    0 never executed
        -: 1002:						}
        -: 1003:					}
        -: 1004:				}
        -: 1005:			}
        -: 1006:
        -: 1007:		}
    #####: 1008:		return 0;
        -: 1009:
        -: 1010:	case steward:
    #####: 1011:		if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1012:		{
        -: 1013:			//+2 cards
    #####: 1014:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1015:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1016:		}
    #####: 1017:		else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1018:		{
        -: 1019:			//+2 coins
    #####: 1020:			state->coins = state->coins + 2;
        -: 1021:		}
        -: 1022:		else
        -: 1023:		{
        -: 1024:			//trash 2 cards in hand
    #####: 1025:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1026:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1027:		}
        -: 1028:
        -: 1029:		//discard card from hand
    #####: 1030:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1031:		return 0;
        -: 1032:
        -: 1033:	case tribute:
    #####: 1034:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1035:			if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1037:				state->deckCount[nextPlayer]--;
        -: 1038:			}
    #####: 1039:			else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1040:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1041:				state->discardCount[nextPlayer]--;
        -: 1042:			}
        -: 1043:			else {
        -: 1044:				//No Card to Reveal
        -: 1045:				if (DEBUG) {
    #####: 1046:					printf("No cards to reveal\n");
call    0 never executed
        -: 1047:				}
        -: 1048:			}
        -: 1049:		}
        -: 1050:
        -: 1051:		else {
    #####: 1052:			if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1053:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1054:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1055:					state->deckCount[nextPlayer]++;
    #####: 1056:					state->discard[nextPlayer][i] = -1;
    #####: 1057:					state->discardCount[nextPlayer]--;
        -: 1058:				}
        -: 1059:
    #####: 1060:				shuffle(nextPlayer, state);//Shuffle the deck
call    0 never executed
        -: 1061:			}
    #####: 1062:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1063:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1064:			state->deckCount[nextPlayer]--;
    #####: 1065:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1066:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1067:			state->deckCount[nextPlayer]--;
        -: 1068:		}
        -: 1069:
    #####: 1070:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1071:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1072:			state->playedCardCount++;
    #####: 1073:			tributeRevealedCards[1] = -1;
        -: 1074:		}
        -: 1075:
    #####: 1076:		for (i = 0; i <= 2; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1077:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1078:				state->coins += 2;
        -: 1079:			}
        -: 1080:
    #####: 1081:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1082:				drawCard(currentPlayer, state);
call    0 never executed
    #####: 1083:				drawCard(currentPlayer, state);
call    0 never executed
        -: 1084:			}
        -: 1085:			else {//Action Card
    #####: 1086:				state->numActions = state->numActions + 2;
        -: 1087:			}
        -: 1088:		}
        -: 1089:
    #####: 1090:		return 0;
        -: 1091:
        -: 1092:	case ambassador:
    #####: 1093:		j = 0;		//used to check if player has enough cards to discard
        -: 1094:
    #####: 1095:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1096:		{
    #####: 1097:			return -1;
        -: 1098:		}
        -: 1099:
    #####: 1100:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1101:		{
    #####: 1102:			return -1;
        -: 1103:		}
        -: 1104:
    #####: 1105:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1106:		{
    #####: 1107:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1108:			{
    #####: 1109:				j++;
        -: 1110:			}
        -: 1111:		}
    #####: 1112:		if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1113:		{
    #####: 1114:			return -1;
        -: 1115:		}
        -: 1116:
        -: 1117:		if (DEBUG)
    #####: 1118:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
call    0 never executed
        -: 1119:
        -: 1120:		//increase supply count for choosen card by amount being discarded
    #####: 1121:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1122:
        -: 1123:		//each other player gains a copy of revealed card
    #####: 1124:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:		{
    #####: 1126:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1127:			{
    #####: 1128:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1129:			}
        -: 1130:		}
        -: 1131:
        -: 1132:		//discard played card from hand
    #####: 1133:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1134:
        -: 1135:		//trash copies of cards returned to supply
    #####: 1136:		for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1137:		{
    #####: 1138:			for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1139:			{
    #####: 1140:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1141:				{
    #####: 1142:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1143:					break;
        -: 1144:				}
        -: 1145:			}
        -: 1146:		}
        -: 1147:
    #####: 1148:		return 0;
        -: 1149:
        -: 1150:	case cutpurse:
        -: 1151:
    #####: 1152:		updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1153:		for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1154:		{
    #####: 1155:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1156:			{
    #####: 1157:				for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1158:				{
    #####: 1159:					if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1160:					{
    #####: 1161:						discardCard(j, i, state, 0);
call    0 never executed
    #####: 1162:						break;
        -: 1163:					}
    #####: 1164:					if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1165:					{
    #####: 1166:						for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1167:						{
        -: 1168:							if (DEBUG)
    #####: 1169:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
call    0 never executed
        -: 1170:						}
    #####: 1171:						break;
        -: 1172:					}
        -: 1173:				}
        -: 1174:
        -: 1175:			}
        -: 1176:
        -: 1177:		}
        -: 1178:
        -: 1179:		//discard played card from hand
    #####: 1180:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1181:
    #####: 1182:		return 0;
        -: 1183:
        -: 1184:
        -: 1185:	case embargo:
        -: 1186:		//+2 Coins
    #####: 1187:		state->coins = state->coins + 2;
        -: 1188:
        -: 1189:		//see if selected pile is in play
    #####: 1190:		if (state->supplyCount[choice1] == -1)
branch  0 never executed
branch  1 never executed
        -: 1191:		{
    #####: 1192:			return -1;
        -: 1193:		}
        -: 1194:
        -: 1195:		//add embargo token to selected supply pile
    #####: 1196:		state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:		//trash card
    #####: 1199:		discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1200:		return 0;
        -: 1201:
        -: 1202:	case outpost:
        -: 1203:		//set outpost flag
    #####: 1204:		state->outpostPlayed++;
        -: 1205:
        -: 1206:		//discard card
    #####: 1207:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1208:		return 0;
        -: 1209:
        -: 1210:	case salvager:
        -: 1211:		//+1 buy
       27: 1212:		state->numBuys++;
        -: 1213:
       27: 1214:		if (choice1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1215:		{
        -: 1216:			//gain coins equal to trashed card
       13: 1217:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 returned 100%
call    1 returned 100%
        -: 1218:			//trash card
       13: 1219:			discardCard(choice1, currentPlayer, state, 1);
call    0 returned 100%
        -: 1220:		}
        -: 1221:
        -: 1222:		//discard card
       27: 1223:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       27: 1224:		return 0;
        -: 1225:
        -: 1226:	case sea_hag:
    #####: 1227:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1228:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1229:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1230:				state->discardCount[i]++;
    #####: 1231:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1232:			}
        -: 1233:		}
    #####: 1234:		return 0;
        -: 1235:
        -: 1236:	case treasure_map:
        -: 1237:		//search hand for another treasure_map
    #####: 1238:		index = -1;
    #####: 1239:		for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1240:		{
    #####: 1241:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1242:			{
    #####: 1243:				index = i;
    #####: 1244:				break;
        -: 1245:			}
        -: 1246:		}
    #####: 1247:		if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1248:		{
        -: 1249:			//trash both treasure cards
    #####: 1250:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1252:
        -: 1253:			//gain 4 Gold cards
    #####: 1254:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1255:			{
    #####: 1256:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1257:			}
        -: 1258:
        -: 1259:			//return success
    #####: 1260:			return 1;
        -: 1261:		}
        -: 1262:
        -: 1263:		//no second treasure_map found in hand
    #####: 1264:		return -1;
        -: 1265:	}
        -: 1266:
    #####: 1267:	return -1;
        -: 1268:}
        -: 1269:
function discardCard called 240 returned 100% blocks executed 78%
      240: 1270:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1271:{
        -: 1272:
        -: 1273:	//if card is not trashed, added to Played pile 
      240: 1274:	if (trashFlag < 1)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -: 1275:	{
        -: 1276:		//add card to played pile
      227: 1277:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      227: 1278:		state->playedCardCount++;
        -: 1279:	}
        -: 1280:
        -: 1281:	//set played card to -1
      240: 1282:	state->hand[currentPlayer][handPos] = -1;
        -: 1283:
        -: 1284:	//remove card from player's hand
      240: 1285:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
      240: 1290:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1291:	{
        -: 1292:		//reduce number of cards in hand
    #####: 1293:		state->handCount[currentPlayer]--;
        -: 1294:	}
        -: 1295:	else
        -: 1296:	{
        -: 1297:		//replace discarded card with last card in hand
      240: 1298:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1299:		//set last card to -1
      240: 1300:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1301:		//reduce number of cards in hand
      240: 1302:		state->handCount[currentPlayer]--;
        -: 1303:	}
        -: 1304:
      240: 1305:	return 0;
        -: 1306:}
        -: 1307:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1308:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1309:{
        -: 1310:	//Note: supplyPos is enum of choosen card
        -: 1311:
        -: 1312:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1313:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1314:	{
    #####: 1315:		return -1;
        -: 1316:	}
        -: 1317:
        -: 1318:	//added card for [whoseTurn] current player:
        -: 1319:	// toFlag = 0 : add to discard
        -: 1320:	// toFlag = 1 : add to deck
        -: 1321:	// toFlag = 2 : add to hand
        -: 1322:
    #####: 1323:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1324:	{
    #####: 1325:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1326:		state->deckCount[player]++;
        -: 1327:	}
    #####: 1328:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1329:	{
    #####: 1330:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1331:		state->handCount[player]++;
        -: 1332:	}
        -: 1333:	else
        -: 1334:	{
    #####: 1335:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1336:		state->discardCount[player]++;
        -: 1337:	}
        -: 1338:
        -: 1339:	//decrease number in supply pile
    #####: 1340:	state->supplyCount[supplyPos]--;
        -: 1341:
    #####: 1342:	return 0;
        -: 1343:}
        -: 1344:
function updateCoins called 68 returned 100% blocks executed 82%
       68: 1345:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1346:{
        -: 1347:	int i;
        -: 1348:
        -: 1349:	//reset coin count
       68: 1350:	state->coins = 0;
        -: 1351:
        -: 1352:	//add coins for each Treasure card in player's hand
      408: 1353:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1354:	{
      340: 1355:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1356:		{
      272: 1357:			state->coins += 1;
        -: 1358:		}
       68: 1359:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1360:		{
    #####: 1361:			state->coins += 2;
        -: 1362:		}
       68: 1363:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1364:		{
    #####: 1365:			state->coins += 3;
        -: 1366:		}
        -: 1367:	}
        -: 1368:
        -: 1369:	//add bonus
       68: 1370:	state->coins += bonus;
        -: 1371:
       68: 1372:	return 0;
        -: 1373:}
        -: 1374:
        -: 1375:
        -: 1376://end of dominion.c
        -: 1377:
